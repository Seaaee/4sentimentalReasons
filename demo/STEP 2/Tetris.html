<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <meta
        http-equiv="X-UA-Compatible"
        content="ie=edge"
    >
    <link
        rel="shortcut icon"
        href="2k.jpg"
        type="image/x-icon"
    >
    <title>俄罗斯方块</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%
        }

        ul,
        li {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        body {
            color: rgb(36, 34, 34);
            font-size: 12px;
            display: flex;
            justify-content: center;
            background: #f6f6f6
        }

        #play_area,
        #play_menu {
            margin-top: 100px;
        }

        #play_area {
            display: flex;
            width: 300px;
            height: 480px;
            border-radius: 2px;
            box-shadow: 0 0 8px #000;
            background-image: linear-gradient(transparent 0, rgba(6, 6, 6, 0.744) 1px),
                linear-gradient(90deg, transparent 0, rgba(6, 6, 6, 0.744) 1px);
            background-size: 20px 20px
        }

        #play_area .play_cell {
            width: 19px;
            height: 19px;
            border: 1px solid transparent;
            position: absolute;
        }

        #play_area .active {
            background: #666;
        }

        #play_are .settle {
            background: #444
        }


        #play_menu {
            margin-left: 80px;
            padding-top: 10px;
            font-size: 1rem;
        }

        #play_menu #play_nextType {
            width: 60px;
            height: 60px;
        }

        #play_menu #play_nextType .play_cell {
            width: 14px;
            height: 14px;
        }

        #play_menu #play_nextType .play_cell,
        #play_area .play_cell {
            border: 1px solid #eee;
            margin: 0 -1px -1px 0;
        }

        button {
            background: #fefefe;
            border: 1px solid #ccc;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            width: 100%;
        }

        button:hover {
            animation: rainbow 0.8s ease-in infinite alternate;
        }

        @keyframes rainbow {


            0% {
                background: rgb(225, 234, 250);
            }

            100% {
                background: rgb(203, 221, 229);
            }
        }

        button .acc {
            background: #666;
            color: #eee
        }

        button .acc:hover {
            background: #333
        }

        #play_btn_start {
            height: 70px;
            width: 160px;
            margin: 40px 10px 0;
            font-size: 1.3rem;
            color: rgb(36, 61, 88);
            font-weight: bolder;
        }

        #play_menu ul {
            display: flex;
            margin-top: 20px;
            width: 180px;
            justify-content: space-evenly
        }

        #play_menu ul li {
            width: 50px;
        }

        #play_menu ul li button {
            height: 50px;
            border-radius: 50%
        }

        #play_score {
            width: 180px;
            height: 160px;
            font-size: 8rem;
            line-height: 160px;
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            font-family: Impact, Haettenschweiler, 'Arial Narrow Bold';
        }

    </style>
</head>

<body>
    <main
        class='wrap'
        id='play_area'
    >
    </main>
    <nav id='play_menu'>
        <p>下一个：</p>
        <div id="play_nextType"></div>
        <button
            id="play_btn_start"
            class='play_btn'
        >开始
        </button>
        <ul>
            <li><button>慢</button></li>
            <li><button>还行</button></li>
            <li><button>快</button></li>
        </ul>
        <div id='play_score'>0</div>
    </nav>
    <script>
        'use strict';

        class Tetris {
            constructor() {
                this.activeCell = document.getElementsByClassName('active');
                this.settleCell = document.getElementsByClassName('settle')
                this.nowArr = undefined;
                this.playArea = document.getElementById('play_area')
                this.playSize = {
                    width: 300,
                    height: 480,
                    left: this.getDistance(true),
                    top: this.getDistance(false)
                }

                this.speed=600;
                this.CELLSIZE = 20;
                this.BLOCK = {
                    BLOCK1: [
                        [1, 0],
                        [1, 0],
                        [1, 1]
                    ],
                    BLOCK2: [
                        [1, 1, 0],
                        [0, 1, 1]
                    ],
                    BLOCK3: [
                        [1, 1],
                        [1, 0],
                        [1, 0],
                    ],
                    BLOCK4: [
                        [1, 1],
                        [1, 1]
                    ],
                    BLOCK5: [
                        [0, 1, 1],
                        [1, 1, 0]
                    ],
                    BLOCK6: [
                        [0, 1, 0],
                        [1, 1, 1]
                    ],
                    BLOCK7: [
                        [1],
                        [1],
                        [1],
                        [1]
                    ]
                }
            }
            getDistance(r) {
                return r ? this.playArea.offsetLeft : this.playArea.offsetTop
            }

            /**
                @param len
                @return midarr
            */
            getMidIndexArr(len) {
                let mid = Math.floor(len / 2)
                return Array.from(new Array(len), (z, index) => index - mid)
            }


            /**
                返回现在active的上下左右和两个位置数组
                @return {
                    bottom:bottom,
                    left:left,
                    right:right,
                    top:top,
                    lefts: lefts,
                    tops: tops
                    }
            */
            getActivePos() {
                let tops = [],
                    lefts = [];
                Array.from(this.activeCell).forEach((itm) => {
                    tops.push(parseInt(itm.style.top))
                    lefts.push(parseInt(itm.style.left))
                })
                let bottom = Math.max(...tops),
                    left = Math.min(...lefts),
                    right = Math.max(...lefts),
                    top = Math.min(...tops);
                return {
                    bottom: bottom,
                    left: left,
                    top: top,
                    lefts: lefts,
                    tops: tops
                }
            }





            /**
                ↑ 变形
                @return {
                    lefts:lefts,
                    tops:tops
                }
                left和top数组
                变形之后的left是之前的left   top是mid top   只有右边可能出界
            */
            turn() {
                let col = this.nowArr.length,
                    row = this.nowArr[0].length,
                    arrTurn = [];
                //矩阵转换 
                for (let i = 0; i < row; i++) {
                    let tmp = []
                    for (let j = 0; j < col; j++) {
                        tmp.push(this.nowArr[col - 1 - j][i])
                    }
                    arrTurn.push(tmp)
                }
                this.nowArr = [...arrTurn]


                let {
                    left,
                    top,
                    bottom
                } = this.getActivePos(),
                    midHeight = Math.ceil((top + bottom) / 40),
                    lefts = [], tops = [],
                    colDex = this.getMidIndexArr(arrTurn.length)
                for (let i = 0; i < arrTurn.length; i++) {
                    for (let j = 0; j < arrTurn[i].length; j++) {
                        if (arrTurn[i][j] === 1) {
                            lefts.push(left + j * this.CELLSIZE);
                            tops.push((midHeight + colDex[i]) * this.CELLSIZE)
                        }
                    }
                }
                // 防止右出界
                while (Math.max(...lefts) > this.playSize.left + this.playSize.width - 20) {
                    lefts.forEach((itm, index) => lefts[index] = itm - 20)
                }
                // 防止出下届
                while (Math.max(...tops) > this.playSize.top + this.playSize.height - 20) {
                    tops.forEach((itm, index) => tops[index] = itm - 20)
                }
                return {
                    lefts: lefts,
                    tops: tops,
                }
            }


            /**                 
                判断是否可以移动
                @param {lefts,tops}
                假设已经移动后的lefts和tops，依次与每个settleCell对比看是否重合
            */
            canMove({
                ll,
                tt
            }) {
                let flag = true,l,t;
                    for (let i = 0; i < tt.length; i++) {
                        l = ll[i]
                        t = tt[i]
                        if (Array.from(this.settleCell).some(function (itm) {
                            (itm.top == t) && (itm.left == l)
                        })) {flag = false}
                    }
                return flag
            }



            /**
                移动 move()  this.CELLSIZEpx
            */
            move() {
                let othis = this
                document.onkeydown = function (e) {
                    let {lefts:ll,tops:tt}=othis.getActivePos()
                    const key = e.keyCode;
                    if(key==37){
                        ll.forEach((itm, index) => ll[index] = itm - othis.CELLSIZE)
                        if (othis.canMove({ll,tt})&& Math.min(...ll) >= othis.playSize.left) {
                            for (let cell of othis.activeCell) {
                                cell.style.left = `${parseInt(cell.style.left) - othis.CELLSIZE}px`
                            }
                        }
                    }else if(key==38){
                        let {tops:tt,lefts:ll} = othis.turn();
                        if (othis.canMove({ll,tt})&& Math.max(...tt) + othis.CELLSIZE <= othis.playSize.top +othis.playSize.height) {
                            for (let i in othis.activeCell) {
                                othis.activeCell[i].style.left = `${ll[i]}px`;
                                othis.activeCell[i].style.top = `${tt[i]}px`
                            }
                        }
                    }else if(key==39){
                        ll.forEach((itm, index) => ll[index] = itm + othis.CELLSIZE)
                        if (othis.canMove({ll,tt})&& Math.max(...ll) + othis.CELLSIZE <= othis.playSize.left+othis.playSize.width){
                            for (let cell of othis.activeCell) {
                                cell.style.left = `${parseInt(cell.style.left)+othis.CELLSIZE}px`
                            }
                        }
                    }else if(key==40){
                        tt.forEach((itm,index)=>tt[index]=itm+othis.CELLSIZE)
                        if (othis.canMove({ll,tt})&&Math.max(...tt) + othis.CELLSIZE <= othis.playSize.top + othis.playSize.height) {
                            for (let cell of othis.activeCell) {
                                cell.style.top = `${parseInt(cell.style.top)+othis.CELLSIZE}px`
                            }
                        }
                    }
                }
            }
            



            /**
             *  新的小方块出现在頂端
             *  @param blcok
             */
            initDraw(block) {
                let len = block.length
                for (let i = 0; i < len; i++) {
                    let rowdex = this.getMidIndexArr(block[i].length)
                    for (let j = 0; j < block[i].length; j++) {
                        if (block[i][j] === 1) {
                            let newBlock = document.createElement('div')
                            newBlock.className = 'play_cell active'
                            newBlock.style.top = `${this.playSize.top+i*this.CELLSIZE}px`
                            newBlock.style.left = `${this.playSize.left+(parseInt(this.playSize.width/40)+rowdex[j])*20}px`
                            this.playArea.appendChild(newBlock)
                        }
                    }
                }
            }

            init() {
                this.nowArr = [...this.BLOCK['BLOCK' + Math.round(Math.random() * (7 - 1) + 1)]];
                this.initDraw(this.nowArr);
                // const autoFall=setInterval(function(){

                // },this.speed)
            }

        }
        window.onload = () => {
            let go = new Tetris();
            go.init()
            go.move()
        }

    </script>
</body>

</html>
