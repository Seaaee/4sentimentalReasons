<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <meta
        http-equiv="X-UA-Compatible"
        content="ie=edge"
    >
    <link
        rel="shortcut icon"
        href="2k.jpg"
        type="image/x-icon"
    >
    <title>俄罗斯方块</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%
        }

        ul,
        li {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        body {
            color: rgb(36, 34, 34);
            font-size: 12px;
            display: flex;
            justify-content: center;
            background: #f6f6f6
        }

        #play_area,
        #play_menu {
            margin-top: 100px;
        }

        #play_area {
            position: relative;
            display: flex;
            width: 300px;
            height: 480px;
            border-radius: 2px;
            box-shadow: 0 0 8px #000;
            background-image: linear-gradient(transparent 0, rgba(6, 6, 6, 0.822) 1px),
                linear-gradient(90deg, transparent 0, rgba(6, 6, 6, 0.815) 1px);
            background-size: 20px 20px
        }

        #play_area .play_cell {
            width: 19px;
            height: 19px;
            border: 1px solid transparent;
            position: absolute;
        }

        #play_area .active {
            background: #222;
        }

        #play_area .settle {
            background: #555
        }


        #play_menu {
            margin-left: 80px;
            padding-top: 10px;
            font-size: 1rem;
        }

        #play_menu #play_nextType {
            width: 60px;
            height: 60px;
        }

        #play_menu #play_nextType .play_cell {
            width: 14px;
            height: 14px;
        }

        #play_menu #play_nextType .play_cell,
        #play_area .play_cell {
            border: 1px solid #eee;
            margin: 0 -1px -1px 0;
        }

        button {
            background: #fefefe;
            border: 1px solid #ccc;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            width: 100%;
        }

        button:hover {
            animation: rainbow 0.8s ease-in infinite alternate;
        }

        @keyframes rainbow {


            0% {
                background: rgb(225, 234, 250);
            }

            100% {
                background: rgb(203, 221, 229);
            }
        }

        button .acc {
            background: #666666;
            color: #eee
        }

        button .acc:hover {
            background: #333
        }

        #play_btn_start {
            height: 70px;
            width: 160px;
            margin: 40px 10px 0;
            font-size: 1.3rem;
            color: rgb(36, 61, 88);
            font-weight: bolder;
        }

        #play_menu ul {
            display: flex;
            margin-top: 20px;
            width: 180px;
            justify-content: space-evenly
        }

        #play_menu ul li {
            width: 50px;
        }

        #play_menu ul li button {
            height: 50px;
            border-radius: 50%
        }

        #play_score {
            width: 180px;
            height: 160px;
            font-size: 8rem;
            line-height: 160px;
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            font-family: Impact, Haettenschweiler, 'Arial Narrow Bold';
        }

    </style>
</head>

<body>
    <main
        class='wrap'
        id='play_area'
    >
    </main>
    <nav id='play_menu'>
        <p>下一个：</p>
        <div id="play_nextType"></div>
        <button
            id="play_btn_start"
            class="pause"
        >PAUSE.
        </button>
        <ul>
            <li><button class='fallSpeed_con'>慢</button></li>
            <li><button class='fallSpeed_con'>还行</button></li>
            <li><button class='fallSpeed_con'>快</button></li>
        </ul>
        <div id='play_score'>0</div>
    </nav>
    <script>
        'use strict';

        class Tetris {
            constructor() {
                this.activeCell = document.getElementsByClassName('active');
                this.settleCell = document.getElementsByClassName('settle');
                this.startBtn=document.getElementById('play_btn_start');
                this.speedConBtn=document.getElementsByClassName('fallSpeed_con')
                this.playArea = document.getElementById('play_area')
                this.playSize = {
                    width: 300,
                    height: 480,
                    left: this.getDistance(true),
                    top: this.getDistance(false)
                }

                this.nowArr = undefined;
                this.autoFall=undefined;

                this.speedArr=[900,500,200];
                this.speed=500
                this.CELLSIZE = 20;
                this.BLOCK = {
                    BLOCK1: [
                        [1, 0],
                        [1, 0],
                        [1, 1]
                    ],
                    BLOCK2: [
                        [1, 1, 0],
                        [0, 1, 1]
                    ],
                    BLOCK3: [
                        [1, 1],
                        [1, 0],
                        [1, 0],
                    ],
                    BLOCK4: [
                        [1, 1],
                        [1, 1]
                    ],
                    BLOCK5: [
                        [0, 1, 1],
                        [1, 1, 0]
                    ],
                    BLOCK6: [
                        [0, 1, 0],
                        [1, 1, 1]
                    ],
                    BLOCK7: [
                        [1],
                        [1],
                        [1],
                        [1]
                    ]
                }
            }
            getDistance(r) {
                return r ? this.playArea.offsetLeft : this.playArea.offsetTop
            }

            /**
                @param len
                @return midarr
            */
            getMidIndexArr(len) {
                let mid = Math.floor(len / 2)
                return Array.from(new Array(len), (z, index) => index - mid)
            }


            /**
                返回现在active的上下左右和两个位置数组
                @return {
                    bottom:bottom,
                    left:left,
                    right:right,
                    top:top,
                    lefts: lefts,
                    tops: tops
                    }
            */
            getActivePos() {
                let tops = [],
                    lefts = [];
                Array.from(this.activeCell).forEach((itm) => {
                    tops.push(parseInt(itm.offsetTop))
                    lefts.push(parseInt(itm.offsetLeft))
                })
                let bottom = Math.max(...tops),
                    left = Math.min(...lefts),
                    right = Math.max(...lefts),
                    top = Math.min(...tops);
                return {
                    bottom: bottom,
                    left: left,
                    top: top,
                    lefts: lefts,
                    tops: tops
                }
            }





            /**
                ↑ 变形
                @return {
                    lefts:lefts,
                    tops:tops
                }
                left和top数组
                变形之后的left是之前的left   top是mid top   只有右边可能出界
            */
            turn() {
                let col = this.nowArr.length,
                    row = this.nowArr[0].length,
                    arrTurn = [];
                //矩阵转换 
                for (let i = 0; i < row; i++) {
                    let tmp = []
                    for (let j = 0; j < col; j++) {
                        tmp.push(this.nowArr[col - 1 - j][i])
                    }
                    arrTurn.push(tmp)
                }
                this.nowArr = [...arrTurn]


                let {
                    left,
                    top,
                    bottom
                } = this.getActivePos(),
                    midHeight = Math.ceil((top + bottom) / 40),
                    lefts = [], tops = [],
                    colDex = this.getMidIndexArr(arrTurn.length)
                for (let i = 0; i < arrTurn.length; i++) {
                    for (let j = 0; j < arrTurn[i].length; j++) {
                        if (arrTurn[i][j] === 1) {
                            lefts.push(left + j * this.CELLSIZE);
                            tops.push((midHeight + colDex[i]) * this.CELLSIZE)
                        }
                    }
                }
                // 防止右出界
                while (Math.max(...lefts) > this.playSize.width - 20) {
                    lefts.forEach((itm, index) => lefts[index] = itm - 20)
                }
                // 防止出下届
                while (Math.max(...tops) > this.playSize.height - 20) {
                    tops.forEach((itm, index) => tops[index] = itm - 20)
                }
                return {
                    lefts: lefts,
                    tops: tops,
                }
            }


            /**                 
                判断是否可以移动
                @param {lefts,tops}
                假设已经移动后的lefts和tops，依次与每个settleCell对比看是否重合
            */
            canMove({
                ll,
                tt
            }) {
                let flag = true,l,t;
                    for (let i = 0; i < tt.length; i++) {
                        l = ll[i]
                        t = tt[i]
                        if (Array.from(this.settleCell).some(function (itm) {
                            return (itm.offsetTop == t) && (itm.offsetLeft == l)
                        })){flag = false}
                    }
                return flag
            }



            /**
                移动 move()  this.CELLSIZEpx
            */
            move() {
                let othis = this
                document.onkeydown = function (e) {
                    let {lefts:ll,tops:tt}=othis.getActivePos()
                    const key = e.keyCode;
                    if(key==37){
                        ll.forEach((itm, index) => ll[index] = itm - othis.CELLSIZE)
                        if (othis.canMove({ll,tt})&& Math.min(...ll) >= 0) {
                            for (let cell of othis.activeCell) {
                                cell.style.left = `${parseInt(cell.offsetLeft) - othis.CELLSIZE}px`
                            }
                        }
                    }else if(key==38){
                        let {tops:tt,lefts:ll} = othis.turn();
                        if (othis.canMove({ll,tt})) {
                            for (let i in othis.activeCell) {
                                othis.activeCell[i].style.left = `${ll[i]}px`;
                                othis.activeCell[i].style.top = `${tt[i]}px`
                            }
                        }
                    }else if(key==39){
                        ll.forEach((itm, index) => ll[index] = itm + othis.CELLSIZE)
                        if (othis.canMove({ll,tt})&& Math.max(...ll) + othis.CELLSIZE <= othis.playSize.width){
                            for (let cell of othis.activeCell) {
                                cell.style.left = `${parseInt(cell.offsetLeft)+othis.CELLSIZE}px`
                            }
                        }
                    }else if(key==40){
                        tt.forEach((itm,index)=>tt[index]=itm+othis.CELLSIZE)
                        if (othis.canMove({ll,tt})&&Math.max(...tt) + othis.CELLSIZE <=  othis.playSize.height) {
                            for (let cell of othis.activeCell) {
                                cell.style.top = `${parseInt(cell.offsetTop)+othis.CELLSIZE}px`
                            }
                        }else{
                            return true
                        }
                    }
                }
            }
            



            /**
             *  新的小方块出现在頂端
             *  @param blcok
             */
            initDraw() {
                this.nowArr = [...this.BLOCK['BLOCK' + Math.round(Math.random() * (7 - 1) + 1)]];
                let len = this.nowArr.length
                for (let i = 0; i < len; i++) {
                    let rowdex = this.getMidIndexArr(this.nowArr[i].length)
                    for (let j = 0; j < this.nowArr[i].length; j++) {
                        if (this.nowArr[i][j] === 1) {
                            let newBlock = document.createElement('div')
                            newBlock.className = 'play_cell active'
                            newBlock.style.top = `${i*this.CELLSIZE}px`
                            newBlock.style.left = `${(parseInt(this.playSize.width/40)+rowdex[j])*20}px`
                            this.playArea.appendChild(newBlock)
                        }
                    }
                }
            }



            goFall(){
                clearTimeout(this.autoFall)
                if(document.onkeydown({keyCode:40})){
                    for(let v of Array.from(this.activeCell)){
                        v.className=v.className.replace('active','settle')
                    }
                    this.start()                        
                }else{
                    this.autoFall=setTimeout(this.goFall.bind(this),this.speed)
                }
            }

            start(){      
                this.initDraw();
                this.autoFall=setTimeout(this.goFall.bind(this),this.speed)
            }

            toggleGame(){
                let flag=this.startBtn.className==='start'?true:false;
                if(flag){
                    this.startBtn.className='pause';
                    this.startBtn.innerText='PAUSE.'
                    this.autoFall=setTimeout(this.goFall.bind(this),this.speed)
                }else{
                    this.startBtn.className='start'
                    this.startBtn.innerText='GO.'
                    clearTimeout(this.autoFall)
                }
            }
            
            init() {
                this.move()
                this.start()
                this.startBtn.onclick=this.toggleGame.bind(this)
                for(let i=0;i<3;i++){
                    this.speedConBtn[i].onclick=function(){
                        this.speed=this.speedArr[i]
                    }.bind(this)
                }
            }

        }
        window.onload = () => {
            let go = new Tetris();
            go.init()
        }

    </script>
</body>

</html>
